from Programmer import *
from ProgramVisitor import ProgramVisitor
from StateManager import StateManager
from QOperator import QOperator
from ExprTransformer import ExprTransformer
from typing import List, Optional
from TypeChecker import *
from StateChecker import *

def envPrint(env:tuple):
    printer = PrettyPrinter()
    lines = []
    for (loci, ty, st, num) in env:
        loci_str = " ".join(loc.accept(printer) for loc in loci)
        ty_str = ty.accept(printer)
        if st:
            st_str = st.accept(printer)
        lines.append(f"Env ⊢ {num} : {loci_str}: {ty_str} ↦ {st_str}")
    print("\n", "\n".join(line for line in lines))


class StateGen(ProgramVisitor):
    def __init__(self, kenv=None, tenv=None, senv=None):
        super().__init__()
        # kind env, can be generated by CollectKind.
        # mapping from function names to mappings.
        # each mapping is a map from variables to kinds in a method.
        # different methods have different mapping
        self.kenv = kenv
        # type env, can be generated by TypeCollector
        # mapping from function names to two lists of pairs.
        # each list contains pairs of a locus and a type
        # meaning that the locus has a certain type
        # different loci in a list are disjoint
        # there are two lists for each function name
        # The first list contains the type information for the loci at the input
        # The second list contains the type information for the loci at the output location
        self.tenv = tenv

        self.senv = senv
        # fkenv a kind env in a function.
        # in visitMethod, we find out the kind-env for the fun-name.
        self.fkenv = None
        #ftenvp gets the locus-list at the input position of a function
        self.ftenvp = None
        # ftenvr gets the locus-list at the output position of a function
        self.ftenvr = None
        #varnums is the locus-list at the input position
        #There is an additional field for each pair (like now it is not a pair, but triple)
        #The third field iin a triple is a generated identifier (a number) to identify the specific locus
        self.varnums = None
        #outvarnums is the locus-list at the ouput position
        self.outvarnums = None
        #The sizemap is for used inside a function
        #This sizemap maps a range in a locus to its size
        #like x[i,j) has the size j - i
        self.sizemap = dict()
        #The counter generates a new identifier for a locus,
        #When generating a locus ID, we increment the counter
        self.counter = 0
        #The function name when visiting a method
        self.fvar = ""
        #For a locus in a spec, we generate Dafny variables for each range in a locus,
        #depending on the types
        #For example, if x[i,j) , y[0,n) |-> en(1).
        #In Qafny, the variables x and y have no extra number identifier, because it is unnecessary
        #In Dafny, each instruction/function call will generate new seq variables
        #So, we need to always generate different new instances for x and y
        #So, for a spec, we will call the counter to generate the new identifier
        #and the Dafny variable for the locus is DVar(x,counter), DVar(y,counter),
        # DVar(amp,counter), and DVar(phase,counter)
        # The variables are also associated with types, and depend on types
        #Now, the DVars above have type seq<real> or seq<seq<bv1>>
        # if we have a en(2) type above, we will have seq<seq<real>> and seq<seq<seq<bv1>>>
        self.qvars = []
        #When analyzing a locus in a specific plance
        #We assign the locus to the global field in the visitor class
        #This will reserves the locus and allow the sub-visitor-call to assign the current locus
        self.locus = []
        self.state_manager = StateManager()
        self.operator = QOperator(self.state_manager)

    def genVarNumMap(self, senv: list[(list[QXQRange], QXQTy)]):
        tmp = []
        for locus, qty, st in senv:
            tmp = tmp + [(locus, qty, st, self.counter)]
            self.counter += 1
        return tmp

    def upvar(self, var: str):
        tmp = self.varnums.get(var)
        self.varnums.update({var:self.varnums.get(var)+1})
        return tmp

    def calRange(self, v: QXCRange):
        '''Converts a QXCRange to a QXAExpr that represents the length of the q-bit array.'''
        if isinstance(v.left(), QXNum) and v.left().num() == 0:
            return v.right() #this is QXBind(id=n)
        return QXBin("-", v.right(), v.left())

    def genSizeMap(self):
        self.sizemap = dict()
        for locus, qty, st, num in self.varnums:
            for elem in locus:
                v = self.calRange(elem.crange())
                self.sizemap.update({(elem.ID(), num):v})

    def removeLocus(self, n:int):
        vs = []
        for i in range(len(self.varnums)):
            locus,qty,st,num = self.varnums[i]
            if n == num:
                vs += self.varnums[i+1:len(self.varnums)]
                break
            else:
                vs += [(locus,qty,st,num)]

        self.varnums = vs


    def replaceType(self, n:int, t:QXQTy):
        vs = []
        for i in range(len(self.varnums)):
            locus,qty,st,num = self.varnums[i]
            if n == num:
                vs += [(locus,t,num)]+self.varnums[i+1:len(self.varnums)]
                break
            else:
                vs += [(locus,qty,st,num)]

        self.varnums = vs

    def updateOutVarNums(self, qstmt):
        if (isinstance(qstmt, QXQAssign) or isinstance(qstmt, QXCast)):
                            for i in range(len(self.outvarnums)):
                                loc, qty, st, num = self.outvarnums[i]
                                if compareLocus(qstmt.locus(), loc) == []:
                                    self.outvarnums[i] = loc, qty, st, self.counter

    def visitMethod(self, ctx: QXMethod):
        """Entry point for symbolic execution"""
        # Process specifications

        self.fvar = str(ctx.ID())
        self.fkenv = self.kenv.get(self.fvar)
        
        self.ftenvp = self.tenv.get(self.fvar)[0]
        # ftenvr is initialized to type env of the ensures clause
        self.ftenvr = self.tenv.get(self.fvar)[1]

        self.fsenvp = self.senv.get(self.fvar)[0]
        # ftenvr is initialized to type env of the ensures clause
        self.fsenvr = self.senv.get(self.fvar)[1]


        print(f"\nVisiting method {self.fvar} with input senv: {self.fsenvp} \nand output senv: {self.fsenvr}")
        #generate varnums for the input tenv
        #varnums is a list of triples (locus, type, counter)
        self.varnums = self.genVarNumMap(self.fsenvp)
        print(f"\nMethod {self.fvar} with input varnums: {self.varnums}")
        self.outvarnums = self.genVarNumMap(self.fsenvr)
        self.genSizeMap()
    #    print(f"sizemap for {self.fvar}: {self.sizemap}")
